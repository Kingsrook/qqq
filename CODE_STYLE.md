# QQQ Code style guidelines

## Java in General

### Formatting

- Formatting should generally be driven by the IntelliJ formatter + Checkstyle.
    - Import this rules file:
        - with
          [https://www.jetbrains.com/help/idea/configuring-code-style.html#import-export-schemes]
          (that link explains how to import it, i think)
        - also recommended that you go into Actions on Save > Reformat Code, and turn it on for java files.
    - Always assume that at any time, any code you write will be re-formatted the next time someone else opens it up, so
      any “special” formatting you do will be lost.
    - Also, checkstyle - will fail builds if outside of what’s allowed.
- We are a little bit precious about whitespace. In general, hopefully, the formatter will take care of this - but a few
  points to mention are:
    - curly brace placement: generally (always?) on the next-line, under the keyword, for opening blocks
    - indention: always 3-spaces. and just don’t use tabs.
    - blank lines - within a block of code, no more than 1 in a row; use them between “logical” sections of related
      lines - let the code breathe. Also 3-blank lines between methods in a class

### Naming

- Prefer long/verbose names over short/abbreviated names.
    - Loop index vars (e.g., i) or like caught-exceptions (e) being some reasonable exceptions.
- For variables, avoid [Hungarian Notation](https://en.wikipedia.org/wiki/Hungarian_notation) (starting variable names
  with an abbreviation of their type, like strZipCode.
    - However, the inverse of that (naming list variables that end in List, or maps that end in Map) is reasonable and
      common.
- For fields (and specifically here, QQQ field meta-data), use lowerCaseFirstCamelStyle.
    - Note that, in a database, we’d expect all_lower_case_with_underscores for column names.
    - QQQ’s “backendName” concept allows us to use a java-style (camelCase) name in our entities & meta-data, and
      database-style (under_scores) in the backend/database (and QInstanceEnricher generally takes care of converting
      between those so you don’t have to do them all by-hand).
- See the QQQ-Specifics section below for comments on QQQ object naming.

### Comments

- Always add Javadoc comments, in block-style (see example below) on classes & methods - even if empty (just to serve as
  a visual break) - ideally though, with a good “how & why” comment (less “what”, unless the “what” isn’t clear). These
  can be easily generated by the **Generate Header Comment** action in
  the [Kingsrook Commentator IntelliJ plugin](https://plugins.jetbrains.com/plugin/19325-kingsrook-commentator).
    - Do not place blank lines after javadoc comments.
    - Example:
      ```java
      /*******************************************************************************
       * Transform step for process that evaluates orders  
       *******************************************************************************/`
      public class EvaluateOrdersTransformStep implements AbstractTransformStep
      ```

    - Key features:
        - Line 1: slash, star, star, star… 80 chars
          long, [full of stars](https://knowyourmeme.com/memes/my-god-its-full-of-stars)
        - Lines 2 through n-1: space, star, star, space, then words.
        - Line n: space, space, 80-chars of stars and a trailing slash.
    - And we tend to not concern ourselves with HTML tags, or even javadoc tags (ala, @param) inside these. We’re not
      opposed to them, but as we don’t often look at these as rendered HTML (rather, just read in the IDE/Github),
      plain-text is a lot easier to both write & read.

- 99% of the time or more, use “flower box” comments within classes & method bodies - as generated by
  the [Kingsrook Commentator IntelliJ plugin](https://plugins.jetbrains.com/plugin/19325-kingsrook-commentator)’s *
  *Create Box Comment** action
    - Also note, if you edit the words inside a box comment, you can re-wrap it **Wrap Comment** action from the
      plugin (pending release during 2024.Q3)
    - Example:

      ```java
      ///////////////////////////////////////////////////////////////////////// 
      // preload all data that will be needed for optimizations.             //
      // note - if we ever "optimize" this to only load the ones needed ("on //
      // this page"), we'd then need to re-fetch/update/clear/etc something  //
      /////////////////////////////////////////////////////////////////////////
      preloadOrderData(runBackendStepInput);
      ```
    - Key features:
        - Lines 1 and n: all slashes
        - Lines 2 through n-1: start with // (slash, slash, space) end with // (space, slash, slash). words inside.
          Right-padded (before the //) as needed, so that all lines are the same length
- We tend to not keep any “zombie code” around - that is - code that used to do a thing (or you think in the future may
  be useful), but you just /* ... */ comment out.
    - Re: “i might want it again later”, that’s part of what version control gives us.
    - If we do ever feel like a “zombie” is worth keeping around - then the requirement is - put a flower-box above it,
      explaining why it’s there.

### Fluent style

- Prefer to use fluent-style constructs when available (e.g., x.with().with().with(); over x.set(); x.set(); x.set();)
    - some of this is style - but - it can also help prevent a class of bugs, wherein a setter is called on the wrong
      instance variable… it’s been seen to happen!

### Primitive Types vs. Wrappers

- We almost always avoid using java's primitive wrapper types, preferring the wrapper types instead (e.g., use Integer
  instead of int)
    - Because much application data may be coming from a database, where it could (often) be null, and of course, the
      primitives can't be null, so for consistency, we lean to always using the wrapper types
    - A real "performance sensitive loop" could be an exception, but only after measuring (profiling).
- Always use .equals to compare numbers instead of == even though
    - In some cases .equals does work but there are
      also [those where it doesn’t](https://javarevisited.blogspot.com/2010/10/what-is-problem-while-using-in.html), so
      it's just a habit to be in.
    - If there are null concerns, Objects.equals(a, b) is a nice null-safe alternative.

### Method Lengths

- Strive for a balance between the two extremes of classes with one 1000-line method, and classes with a hundred 10-line
  methods. For a 1000 line class, maybe twenty 50-line methods “feels” like a reasonable balance.
    - (generally speaking) less experienced developers tend to err on the side of the 1000 line method - but those tend
      to be pretty hard to (unit) test, and can get overly complex in their logic / number of local vars, etc. So
      splitting up into multiple methods (even if the code in them isn’t necessarily going to be reused anywhere) can
      help keep the mental load down when revisiting the code in the future.
    - (generally speaking) some more experienced (and/or “extremists”) take views like “no method should be longer than
      1 screen” or “only every do 1 thing (the way _I_ choose to define a thing) in a method”. This can lead to code
      that is also very hard to follow, when you have to just keep jumping from method to method to method to method to
      method in your IDE to actually find where anything happens.
    - So, we seek balance in the force.

### Line Lengths

- We do not enforce a limit on line lengths, and generally (due to living in the time of big monitors), we are okay with
  long lines.
- That being said, when combined with fluent style (see above), there are certainly times when we write statements that
  would just be silly to have on one line - so, we do break those up (with dots going on new lines).
    - Unfortunately, this is a style/feeling thing, where we don’t have any coded “rules” for how to do it…

### Imports

- Re: statically-importing static methods vs. qualified calls:
    - We DO prefer to do static-imports of utility methods for common utility classes - that is - classes that might be
      used in like 75% of all classes of a given kind. For example, in unit tests - statically import the various
      assertXyz methods from Assertions or assert4j. Or in mainline code, statically import the logPairs method or maybe
      the members of the QFilterOperator enum .
        - The reason being, because these commonly used constructs in this codebase are used “everywhere”, so anyone
          reading this code should quickly recognize them and not wonder what they are or where they’re defined.
    - However - for more specialized utilities, prefer qualified references - e.g.,
      ShipingUtilities.getMilesBetweenZipCodes() or FreightUtilities.UPS_CARRIER_CODE.
        - The reason here being, these less-common constructs - one will typically assume, if just seeing them as a
          bare-word (in a code review or otherwise), that they are locally defined, and then it’ll add can add some
          additional mental load and/or time-spent-searching if they aren’t found in the local file.

- We do not use * (wildcard) imports.
    - The general reason being, they can introduce some collisions (e.g., importing java.io.*, then trying to use a File
      class from some other package, and temporarily being confused).
    - Also, the IDE is quite good at managing imports, and they should (hopefully?) always be folded away, so there’s
      virtually no cost in having them all spelled out.

### Logging

- We use the `QLogger` QQQ wrapper on top of `log4j2`.
- Put a logger in your class via:
  ```java
  private static final QLogger LOG = QLogger.getLogger(YourClass.class);
  ```
- Use the overloaded `LOG.info`, `LOG.debug`, LOG`.warn`, etc methods that take `LogPair` objects (preferably generated
  via the static `logPair(key, value)` method (preferably statically imported)), and if you have an exception, then the
  overloads that take an exception as a parameter.
    - This gives us JSON-formatted logs in our log aggregator (Loggly), which facilitates structured searches,
      dashboards, and other general goodness
- Log levels can be tricky to get right. For warn and error levels, the “goal” is that they don’t happen (e.g., if a
  warn or error is logged, in theory, it should mean something an engineer needs to take action on). I’m not
  sure if we meet that goal…
- Between warn and error - the balance should probably be like 95% warn, 5% error. Like a warn would be for an uncaught
  exception in a loop processing some records - and an error would be “we couldn’t connect to the database” (so, stuff
  more like at the framework level or an integration level maybe).
- Generally avoid `System.out` and `System.err` and `e.printStackTrace()` - any of these should be flagged in a code
  review.

## QQQ Application Specifics

### MetaDataProducers

- In general,new metaData objects should be defined in a new class that implements MetaDataProducerInterface, under an
  appropriate metadata subpackage.
  - Although, a newer also-prefered flavor is the annotation-based entities and enums... 
- Benefits of this approach (compared to old ways we’ve done it):
    - It provides strong version of enforcing only
      a [single concept per-class](https://en.wikipedia.org/wiki/Single-responsibility_principle).
    - It doesn’t require you to manually add an instantiation and call to the new class to the instance builder method.
    - It lets us implement the convention of defining a public static final String NAME in each of those classes, which
      can then be referenced anywhere else in the codebase that we need the name of the meta-data object.
    - We find that putting each individual meta-data producer into its own class makes finding them (for maintaining
      them over time) much easier.
        - e.g., _I need to edit the FooBar possible value source… “let me ask IntelliJ to open a file with a name
          containing FooBar MetaDataProducer” vs. “now in what class did we define the defineFooBar method - was it
          CoreMetaDataProducer? no, maybe Shipping? Fulfillment? etc._

Note - a suggested way to create new MetaDataProducer classes, is using the QQQ App Developer plugin for IntelliJ - just
right-click on the package where you want the new class, and choose **New → QQQ MetaDataProducer** - enter the ‘base
name’ of your object (e.g., MyAwesomeNewTable) and the meta-data-type (e.g., QTableMetaData, QProcessMetaData,
QPossibleValueSource, QJoinMetaData, etc), and a stub will be generated.

#### Naming for MetaData objects and MetaDataProducer classes

- Include a public static final String NAME in your MetaDataProducer class, to name the object being created by the
  class
    - Tables that are based on a RecordEntity are an exception here, where the entity class’s TABLE_NAME constant should
      be used instead.
    - use lowerCaseFirstCamelStyle for those NAME values.
    - A good recipe for process names is a verb + noun phrase, that would describe what the process does (the verb) and
      what object type (the noun) it does it to. e.g.:
        - Cancel + Order + Process
- For a MetaDataProducer class name, use the object’s NAME (but with the first letter capitalized (because it is a java
  class)), then the kind of meta-data that it is (e.g., Table, Process, Widget, App, PVS or PossibleValueSource (PVS
  being preferred, for some degree of brevity…), then MetaDataProducer.
    - e.g.:
        - Order + Table + MetaDataProducer
        - SendImportantMessage + Process + MetaDataProducer
        - CoolParcels + Widget + MetaDataProducer
        - DailyDashboard + App + MetaDataProducer
    - For Joins:
        - Include both table names (left, then right), with Join between them. e.g., FooJoinBarMetaDataProducer (rather
          than FooJoinBarJoinMetaDataProducer)

### RecordEntities

- QQQ does not _require_ that tables have corresponding entity classes (entity beans), and for the first few months of
  the development of, we did not use them.
- However, we soon found that we do like to have them (for the benefits they provide - of compile-time checks on field
  names and types, mainly).
- As such, it is our standard that we do create a RecordEntity class for almost all tables that we are building in
  QQQ core, apps, and qbits.  
- And, in early 2025, the @QMetaDataProducingEntity annotation was introduced, which became a preferred way to make
  table meta data too.
